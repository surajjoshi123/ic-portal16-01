{"ast":null,"code":"/*! npm.im/iphone-inline-video 2.2.2 */\nimport { frameIntervalometer } from 'intervalometer';\n\nfunction preventEvent(element, eventName, test) {\n  function handler(e) {\n    if (!test || test(element, eventName)) {\n      e.stopImmediatePropagation(); // // console.log(eventName, 'prevented on', element);\n    }\n  }\n\n  element.addEventListener(eventName, handler); // Return handler to allow to disable the prevention. Usage:\n  // const preventionHandler = preventEvent(el, 'click');\n  // el.removeEventHandler('click', preventionHandler);\n\n  return handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n  function get() {\n    return sourceObject[propertyName];\n  }\n\n  function set(value) {\n    sourceObject[propertyName] = value;\n  }\n\n  if (copyFirst) {\n    set(object[propertyName]);\n  }\n\n  Object.defineProperty(object, propertyName, {\n    get: get,\n    set: set\n  });\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n  sourceObject.addEventListener(eventName, function () {\n    return object.dispatchEvent(new Event(eventName));\n  });\n}\n\nfunction dispatchEventAsync(element, type) {\n  Promise.resolve().then(function () {\n    element.dispatchEvent(new Event(type));\n  });\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\nvar IIV = 'bfred-it:iphone-inline-video';\nvar IIVEvent = 'bfred-it:iphone-inline-video:event';\nvar IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';\nvar IIVPause = 'bfred-it:iphone-inline-video:nativepause';\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n  var audio = new Audio();\n  proxyEvent(video, 'play', audio);\n  proxyEvent(video, 'playing', audio);\n  proxyEvent(video, 'pause', audio);\n  audio.crossOrigin = video.crossOrigin; // 'data:' causes audio.networkState > 0\n  // which then allows to keep <audio> in a resumable playing state\n  // i.e. once you set a real src it will keep playing if it was if .play() was called\n\n  audio.src = video.src || video.currentSrc || 'data:'; // // if (audio.src === 'data:') {\n  //   TODO: wait for video to be selected\n  // // }\n\n  return audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n  // Allow one timeupdate event every 200+ ms\n  if ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n    video[IIVEvent] = true;\n    lastTimeupdateEvent = Date.now();\n  }\n\n  if (!rememberOnly) {\n    video.currentTime = time;\n  }\n\n  lastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n  return player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n  var player = this; // // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\n  if (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n    if (!player.hasAudio) {\n      player.driver.currentTime = player.video.currentTime + timeDiff * player.video.playbackRate / 1000;\n\n      if (player.video.loop && isPlayerEnded(player)) {\n        player.driver.currentTime = 0;\n      }\n    }\n\n    setTime(player.video, player.driver.currentTime);\n  } else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n    // This should happen when the source is available but:\n    // - it's potentially playing (.paused === false)\n    // - it's not ready to play\n    // - it's not loading\n    // If it hasAudio, that will be loaded in the 'emptied' handler below\n    player.video.load(); // // console.log('Will load');\n  } // // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\n  if (player.video.ended) {\n    delete player.video[IIVEvent]; // Allow timeupdate event\n\n    player.video.pause(true);\n  }\n}\n/**\n * METHODS\n */\n\n\nfunction play() {\n  // // console.log('play');\n  var video = this;\n  var player = video[IIV]; // If it's fullscreen, use the native player\n\n  if (video.webkitDisplayingFullscreen) {\n    video[IIVPlay]();\n    return;\n  }\n\n  if (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n    // // console.log('src changed on play', video.src);\n    setTime(video, 0, true);\n    player.driver.src = video.src;\n  }\n\n  if (!video.paused) {\n    return;\n  }\n\n  player.paused = false;\n\n  if (video.buffered.length === 0) {\n    // .load() causes the emptied event\n    // the alternative is .play()+.pause() but that triggers play/pause events, even worse\n    // possibly the alternative is preventing this event only once\n    video.load();\n  }\n\n  player.driver.play();\n  player.updater.start();\n\n  if (!player.hasAudio) {\n    dispatchEventAsync(video, 'play');\n\n    if (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n      // // console.log('onplay');\n      dispatchEventAsync(video, 'playing');\n    }\n  }\n}\n\nfunction pause(forceEvents) {\n  // // console.log('pause');\n  var video = this;\n  var player = video[IIV];\n  player.driver.pause();\n  player.updater.stop(); // If it's fullscreen, the developer the native player.pause()\n  // This is at the end of pause() because it also\n  // needs to make sure that the simulation is paused\n\n  if (video.webkitDisplayingFullscreen) {\n    video[IIVPause]();\n  }\n\n  if (player.paused && !forceEvents) {\n    return;\n  }\n\n  player.paused = true;\n\n  if (!player.hasAudio) {\n    dispatchEventAsync(video, 'pause');\n  } // Handle the 'ended' event only if it's not fullscreen\n\n\n  if (video.ended && !video.webkitDisplayingFullscreen) {\n    video[IIVEvent] = true;\n    dispatchEventAsync(video, 'ended');\n  }\n}\n/**\n * SETUP\n */\n\n\nfunction addPlayer(video, hasAudio) {\n  var player = {};\n  video[IIV] = player;\n  player.paused = true; // Track whether 'pause' events have been fired\n\n  player.hasAudio = hasAudio;\n  player.video = video;\n  player.updater = frameIntervalometer(update.bind(player));\n\n  if (hasAudio) {\n    player.driver = getAudioFromVideo(video);\n  } else {\n    video.addEventListener('canplay', function () {\n      if (!video.paused) {\n        // // console.log('oncanplay');\n        dispatchEventAsync(video, 'playing');\n      }\n    });\n    player.driver = {\n      src: video.src || video.currentSrc || 'data:',\n      muted: true,\n      paused: true,\n      pause: function () {\n        player.driver.paused = true;\n      },\n      play: function () {\n        player.driver.paused = false; // Media automatically goes to 0 if .play() is called when it's done\n\n        if (isPlayerEnded(player)) {\n          setTime(video, 0);\n        }\n      },\n\n      get ended() {\n        return isPlayerEnded(player);\n      }\n\n    };\n  } // .load() causes the emptied event\n\n\n  video.addEventListener('emptied', function () {\n    // // console.log('driver src is', player.driver.src);\n    var wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\n    if (player.driver.src && player.driver.src !== video.src) {\n      // // console.log('src changed to', video.src);\n      setTime(video, 0, true);\n      player.driver.src = video.src; // Playing videos will only keep playing if no src was present when .play()â€™ed\n\n      if (wasEmpty || !hasAudio && video.autoplay) {\n        player.driver.play();\n      } else {\n        player.updater.stop();\n      }\n    }\n  }, false); // Stop programmatic player when OS takes over\n\n  video.addEventListener('webkitbeginfullscreen', function () {\n    if (!video.paused) {\n      // Make sure that the <audio> and the syncer/updater are stopped\n      video.pause(); // Play video natively\n\n      video[IIVPlay]();\n    } else if (hasAudio && player.driver.buffered.length === 0) {\n      // If the first play is native,\n      // the <audio> needs to be buffered manually\n      // so when the fullscreen ends, it can be set to the same current time\n      player.driver.load();\n    }\n  });\n\n  if (hasAudio) {\n    video.addEventListener('webkitendfullscreen', function () {\n      // Sync audio to new video position\n      player.driver.currentTime = video.currentTime; // // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n    }); // Allow seeking\n\n    video.addEventListener('seeking', function () {\n      if (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n        // // console.log('User-requested seeking');\n        player.driver.currentTime = video.currentTime;\n      }\n    });\n  }\n}\n\nfunction preventWithPropOrFullscreen(el) {\n  var isAllowed = el[IIVEvent];\n  delete el[IIVEvent];\n  return !el.webkitDisplayingFullscreen && !isAllowed;\n}\n\nfunction overloadAPI(video) {\n  var player = video[IIV];\n  video[IIVPlay] = video.play;\n  video[IIVPause] = video.pause;\n  video.play = play;\n  video.pause = pause;\n  proxyProperty(video, 'paused', player.driver);\n  proxyProperty(video, 'muted', player.driver, true);\n  proxyProperty(video, 'playbackRate', player.driver, true);\n  proxyProperty(video, 'ended', player.driver);\n  proxyProperty(video, 'loop', player.driver, true); // IIV works by seeking 60 times per second.\n  // These events are now useless.\n\n  preventEvent(video, 'seeking', function (el) {\n    return !el.webkitDisplayingFullscreen;\n  });\n  preventEvent(video, 'seeked', function (el) {\n    return !el.webkitDisplayingFullscreen;\n  }); // Limit timeupdate events\n\n  preventEvent(video, 'timeupdate', preventWithPropOrFullscreen); // Prevent occasional native ended events\n\n  preventEvent(video, 'ended', preventWithPropOrFullscreen);\n}\n\nfunction enableInlineVideo(video, opts) {\n  if (opts === void 0) opts = {}; // Stop if already enabled\n\n  if (video[IIV]) {\n    return;\n  } // Allow the user to skip detection\n\n\n  if (!opts.everywhere) {\n    // Only iOS8 and 9 are supported\n    if (!iOS8or9) {\n      return;\n    } // Stop if it's not an allowed device\n\n\n    if (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n      return;\n    }\n  } // Try to pause\n\n\n  video.pause(); // Prevent autoplay.\n  // An non-started autoplaying video can't be .pause()'d\n\n  var willAutoplay = video.autoplay;\n  video.autoplay = false;\n  addPlayer(video, !video.muted);\n  overloadAPI(video);\n  video.classList.add('IIV'); // Autoplay\n\n  if (video.muted && willAutoplay) {\n    video.play();\n    video.addEventListener('playing', function restoreAutoplay() {\n      video.autoplay = true;\n      video.removeEventListener('playing', restoreAutoplay);\n    });\n  }\n\n  if (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n    console.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n  }\n}\n\nexport default enableInlineVideo;","map":{"version":3,"names":["frameIntervalometer","preventEvent","element","eventName","test","handler","e","stopImmediatePropagation","addEventListener","proxyProperty","object","propertyName","sourceObject","copyFirst","get","set","value","Object","defineProperty","proxyEvent","dispatchEvent","Event","dispatchEventAsync","type","Promise","resolve","then","iOS8or9","document","head","style","matchMedia","matches","IIV","IIVEvent","IIVPlay","IIVPause","getAudioFromVideo","video","audio","Audio","crossOrigin","src","currentSrc","lastRequests","requestIndex","lastTimeupdateEvent","setTime","time","rememberOnly","Date","now","currentTime","isPlayerEnded","player","driver","duration","update","timeDiff","readyState","HAVE_FUTURE_DATA","hasAudio","playbackRate","loop","networkState","NETWORK_IDLE","buffered","length","load","ended","pause","play","webkitDisplayingFullscreen","paused","updater","start","HAVE_ENOUGH_DATA","forceEvents","stop","addPlayer","bind","muted","wasEmpty","autoplay","indexOf","preventWithPropOrFullscreen","el","isAllowed","overloadAPI","enableInlineVideo","opts","everywhere","iPad","ipad","navigator","userAgent","willAutoplay","classList","add","restoreAutoplay","removeEventListener","platform","console","warn"],"sources":["D:/TestingIC/Indian Culture 2.0 backup/headernbanner/node_modules/iphone-inline-video/dist/iphone-inline-video.es-modules.js"],"sourcesContent":["/*! npm.im/iphone-inline-video 2.2.2 */\nimport { frameIntervalometer } from 'intervalometer';\n\nfunction preventEvent(element, eventName, test) {\n\tfunction handler(e) {\n\t\tif (!test || test(element, eventName)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// // console.log(eventName, 'prevented on', element);\n\t\t}\n\t}\n\telement.addEventListener(eventName, handler);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\n\nvar IIV = 'bfred-it:iphone-inline-video';\nvar IIVEvent = 'bfred-it:iphone-inline-video:event';\nvar IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';\nvar IIVPause = 'bfred-it:iphone-inline-video:nativepause';\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// // if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// // }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// Allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[IIVEvent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n\t\t// This should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// // console.log('Will load');\n\t}\n\n\t// // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[IIVEvent]; // Allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// // console.log('play');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\t// If it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPlay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// // console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (video.buffered.length === 0) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// // console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// // console.log('pause');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// If it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\n\t// Handle the 'ended' event only if it's not fullscreen\n\tif (video.ended && !video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVEvent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = {};\n\tvideo[IIV] = player;\n\tplayer.paused = true; // Track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = frameIntervalometer(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// // console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// Media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// // console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// // console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// Playing videos will only keep playing if no src was present when .play()â€™ed\n\t\t\tif (wasEmpty || (!hasAudio && video.autoplay)) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// Stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// Make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// Play video natively\n\t\t\tvideo[IIVPlay]();\n\t\t} else if (hasAudio && player.driver.buffered.length === 0) {\n\t\t\t// If the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// Sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// Allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// // console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction preventWithPropOrFullscreen(el) {\n\tvar isAllowed = el[IIVEvent];\n\tdelete el[IIVEvent];\n\treturn !el.webkitDisplayingFullscreen && !isAllowed;\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[IIV];\n\tvideo[IIVPlay] = video.play;\n\tvideo[IIVPause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\n\t// IIV works by seeking 60 times per second.\n\t// These events are now useless.\n\tpreventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });\n\tpreventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });\n\n\t// Limit timeupdate events\n\tpreventEvent(video, 'timeupdate', preventWithPropOrFullscreen);\n\n\t// Prevent occasional native ended events\n\tpreventEvent(video, 'ended', preventWithPropOrFullscreen);\n}\n\nfunction enableInlineVideo(video, opts) {\n\tif ( opts === void 0 ) opts = {};\n\n\t// Stop if already enabled\n\tif (video[IIV]) {\n\t\treturn;\n\t}\n\n\t// Allow the user to skip detection\n\tif (!opts.everywhere) {\n\t\t// Only iOS8 and 9 are supported\n\t\tif (!iOS8or9) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop if it's not an allowed device\n\t\tif (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Try to pause\n\tvideo.pause();\n\n\t// Prevent autoplay.\n\t// An non-started autoplaying video can't be .pause()'d\n\tvar willAutoplay = video.autoplay;\n\tvideo.autoplay = false;\n\n\taddPlayer(video, !video.muted);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\n\t// Autoplay\n\tif (video.muted && willAutoplay) {\n\t\tvideo.play();\n\t\tvideo.addEventListener('playing', function restoreAutoplay() {\n\t\t\tvideo.autoplay = true;\n\t\t\tvideo.removeEventListener('playing', restoreAutoplay);\n\t\t});\n\t}\n\n\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\nexport default enableInlineVideo;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}